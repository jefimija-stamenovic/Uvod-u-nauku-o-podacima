---
title: "AirBnb"
author: "Jefimija Stamenović"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Uvod

Za ovaj seminarski rad je korišćen skup podataka "Airbnb" istoimene platforme. Skup podataka je dostupan na sledećem linku: <https://www.kaggle.com/datasets/ashishjangra27/airbnb-dataset>.

Airbnb je online platforma za rezervisanje smeštaja popularna širom sveta. Ona omogućava korisnicima da lako i brzo rezervišu smeštaj bilo gde u svetu bilo kad, a omogućava i ugostiteljima da lakše dođu do svojih mušterija tako što mogu da postave oglas za izdavanje smeštaja.

Ovaj skup podataka sadrži detalje informacije o različitim Airbnb smeštajima u različitim državama. Sadrži informacije o smeštaju, domaćinu, lokaciji, ceni, sadržaju i recenzijama gostiju.

Odabrani skup podataka će biti korišćen za predikciju cene smeštaja.

# Opis podataka

Odabrani skup podataka ima 12805 observacija i 23 atributa. U nastavku su dati nazivi atributa i njihovo značenje: • id - jedinstveni identifikator oglasa za smeštaj\
• name - naziv oglasa • rating - prosečna ocena • reviews: Broj primljenih recenzija • host_name: Ime domaćina • host_id: Jedinstveni identifikator za domaćina • address: Lokacija smeštaja (grad, region, država) • features: Sažetak karakteristika (broj gostiju, spavaćih soba, kreveta, kupatila) • amenities: Lista ponuđenih pogodnosti • price: Cena po noćenju u lokalnoj valuti • country: Država u kojoj se nalazi smeštaj • bathrooms: Broj kupatila • beds: Broj kreveta • guests: Broj gostiju koje smeštaj može primiti • toilets: Broj toaleta • bedrooms: Broj spavaćih soba • studios: Broj studio jedinica • checkin - vreme prijave, odnosno vreme dolaska u smeštaj koje je domaćin naveo prilikom kreiranja oglasa • checkout: vreme odjave, odnosno vreme napuštanja smeštaja koje je domaćin naveo prilikom kreiranja oglasa

# Priprema podataka

## Učitavanje biblioteka

Za analizu, vizuelizaciju i predviđanje, neophodno je da učitamo sledeće pakete za rad

```{r}
library(tidyverse)
library(corrplot)
library(car)
library(ggplot2)
library(tidymodels)
library(countrycode)
```

## Učitavanje podataka

Skup podataka koji će biti korišćen, biće učitan u promenljivu *airbnb_df.*

```{r}
airbnb_df = read.csv('airbnb.csv')
```

Nakon učitavanja skupa, treba da vidimo koliko je obiman skup podataka tj. koliki je broj redova (observacija) i broj kolona (prediktora).

```{r}
rows = nrow(airbnb_df)
columns = ncol(airbnb_df)
```

Pošto smo odredili vrednosti promenljivih, ispisaćemo ih i videćemo koje su njihove vrednosti zapravo

```{r}
sprintf("Broj redova: %d", rows)
sprintf("Broj kolona: %d", columns)
```

Ovaj skup podataka sadrži poprilično veliki broj redova, tj. observacija - čak 12805, a broj kolona tj. atributa (*features*) je 23.

Nakon što imamo informaciju o obimu skupa podataka i nazivima kolona, možemo da pogledamo prvih nekoliko redova kako bismo dobili inicijalnu sliku o podacima

```{r}
head(airbnb_df)
```

Na osnovu prvih nekoliko redova, možemo primetiti da kolona X reprezentuje indeks datog reda, pa ćemo ispraviti učitavanje skupa podataka u skladu sa tim

```{r}
airbnb_df = read.csv('airbnb.csv', row.names = "X")
head(airbnb_df)
```

Pre nego što krenemo dalje, pogledaćemo nazive kolona

```{r}
colnames(airbnb_df)
```

Primetile smo slovnu grešku u koloni *hourse_rules*. Ova kolona se odnosi na kućna pravila, tako da ćemo je preimenovati u *house_rules*

```{r}
airbnb_df <- airbnb_df %>%
  rename(house_rules = hourse_rules)
```

Potrebno je da se upoznamo sa podacima i njihovim tipovima. Zato ćemo koristiti funkcije *summary* i *str*

```{r}
summary(airbnb_df)
```

Možemo da vidimo neke osnovne informacije za numeričke vrednosti - kvantili, maksimum, minimum, medijanu, za kategorijske možemo da vidimo koliki je broj pojavljivanja i koji je tip podatka najčešće pojavljivana vrednost. **Za sad nemamo uočene NA vrednosti ni za numeričke ni za kategorijske promenljive.**

Da vidimo šta možemo da dobijemo od informacija na osnovu funkcije *str*

```{r}
str(airbnb_df)
```

Vidimo da imamo dosta kolona koje su tekstualnog formata. Potencijalni problemi sa njima su:

-   Mogu postojati nepotrebne beline u tekstovima

-   Funkcija *summary* ne detektuje prazan string kao NA vrednost što znači da je moguće da imamo skrivene NA vrednosti u vidu praznog stringa

Prvo ćemo se pozabaviti problemom prve tačke. Pogledaćemo koje su to kolone koje su tipa *chr*.

```{r}
airbnb_df %>%
  select_if(is.character) %>%
  str()
```

Stvarno imamo umetnute beline u kolonama *country, checkin, checkout*, međutim, moguće je da se isti problem javlja i u ostalim kolonama, ali da ne možemo da vidimo. Sledećim nizom instrukcija rešavamo problem umetnutih belina na početak i kraj teksta:

```{r}
airbnb_df = airbnb_df %>%
  mutate(across(where(is.character), trimws))
```

Da bi bio garantovan rezultat, pogledaćemo početne vrednosti u kolonama *country, checkout, checkin* jer je u njima inicijalno i primećen problem:

```{r}
airbnb_df %>%
  select(country, checkin, checkout) %>%
  str()
```

Dakle, nemamo više problem belina.

## Čišćenje podataka

Drugi problem promenjlivih tekstualnog formata jeste da li je njihova vrednost prazan string jer ako jesu, onda su to NA vrednosti. Zato ćemo proveriti da li ih zaista i ima među podacima:

```{r}
na_values <- airbnb_df %>% 
  select(where(is.character)) %>%
  sapply(function(col) {
    sum(col == "", na.rm = TRUE) + sum(is.na(col))
  })
na_values = data.frame(na_count = na_values)
na_values
```

Imamo NA vrednosti u kolonama host_name, checkin, checkout. Da bi donele pravu odluku o tome da li treba brisati redove ili kolone sa tim vrednostima, ili pak, možemo da odradimo imputaciju, odredićemo procentualni udeo NA vrednosti.

```{r}
na_values_filtered <- na_values %>%
  filter(na_count > 0) %>%
  mutate(
    na_percentage=(na_count*100)/rows
  )
na_values_filtered
```

Prikazaćemo ovo i vizuelno putem grafika:

```{r}

predictors = row.names(na_values_filtered) 
ggplot(na_values_filtered, aes(x = predictors, y = na_percentage, fill=predictors)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = sprintf("%.2f%% (%d)", na_percentage, na_count)),
            vjust = -0.5, color = "black", size = 4) +
  ylim(0, 100) +
  labs(title = "NA values by predictor",
       x = "Predictor", 
       y = "NA in %") + 
  theme_minimal() +
  theme(legend.position = "bottom") + 
  scale_fill_brewer(palette = "Set2")
```

Na osnovu dobijenih vrednosti i prikazanog grafika, možemo zaključiiti sledeće:

-   kolona *checkin* ima 6,25% NA vrednosti, odnosno fali 800 podataka u ovoj koloni. Ako bismo razmatrali brisanje redova, mogli bi da ostanemo bez dobrog broja podataka za obučavanje modela, tako da brisanje redova ne dolazi u obzir. Brisanje kolone bi već mogli da razmotrimo, ali daljom analizom utvrdićemo da li je bolje rešenje brisanje ili imputacija podataka.

-   kolona *checkout* ima čak 20% NA vrednosti (brojčano 2450), dakle ne bi bilo pametno da redove brišemo jer imaju veliki udeo. Što se kolone tiče, ni nju nije preporučljivo da brišemo, ima solidan broj podataka, tako da je bolja opcija imputacija podataka za NA vrednosti

-   mogli bismo slobodno da obrišemo redove gde imamo nedostajuću vrednost u koloni *host_name* jer je njihov udeo mizeran, svega 0.06% procentualno, a 8 redova brojčano.

Nakon što smo identifikovali NA vrednosti, za obradu NA vrednosti su donete sledeći zaključci:

1)  obrisaćemo redove gde je NA vrednost za host_name jer je broj redova izuzetno mali, pa neće značajno uticati

2)  potrebno je odraditi imputaciju podataka za NA vrednosti u kolonama *checkin* i *checkout*.

Za kolonu host_name je donet zaključak da redove koji imaju NA vrednosti možemo obrisati jer ih je jako malo (ni 1%). Prvo ćemo prebaciti prazne stringove u NA vrednosti:

```{r}
airbnb_df$host_name[airbnb_df$host_name == ""] = NA
sum(is.na(airbnb_df$host_name))
```

Sada kada imamo NA vrednosti, možemo da obrišemo te redove:

```{r}
airbnb_df = drop_na(airbnb_df, host_name)
sum(is.na(airbnb_df$host_name))
rows = nrow(airbnb_df)
```

Nedostajuće vrednosti i dalje imamo u još dve kolone - *checkin* i *checkout*. S obzirom da je broj nedostajućih vrednosti značajan i za jednu i za drugu kolonu, ne smemo da radimo brisanje po redovima. Zato ćemo odraditi imputaciju tih vrednosti.

Pažljivom analizom skupa podataka, uočile smo da u koloni *house_rules* imamo dodatne informacije kao što su: kad je check-in, kad je check-out, da li su dozvoljeni ljubimci, pušenje, itd.

```{r}
head(airbnb_df$house_rules) 
```

Dakle, imamo kolone check-in i check-out, ali imamo i njihove vrednosti u okviru kolone safety_rules. Postavljamo sledeća pitanja, da li postoje vrednosti za check-in i check-out u ovoj koloni, a da ih nemamo u samim kolonama check-in i check-out? Takođe, da li je možda skuplje ako je u smeštaju dozvoljeno pušenje, kućni ljubimci itd.

Krenućemo sa kolonom *checkin*. Potrebno je da iz vrednosti u okviru *house_rules* izvučemo vrednosti za checkin, a to možemo upotrebom regex-a:

```{r}
regex <- "Check-in: [^,]+"
check_info = str_extract(airbnb_df$house_rules, regex)
check_info = str_replace(check_info, "Check-in: ", "")
check_info = str_replace_all(check_info, ":", " ")
check_info = data.frame(checkin_possible=check_info)
head(check_info)
```

Dodaćemo kolonu checkin u *data frame check_info* koji smo upravo napravile. Cilj nam je da nađemo one observacije koje nemaju vrednost u koloni *checkin*, ali imaju u koloni *checkin_possible*.

```{r}
check_info$checkin_real=airbnb_df$checkin
head(check_info)
```

Vidimo da su vrednosti za prvih nekoliko redova iste, ali proverićemo da li to važi za sve observacije. Ako važi, odnosno ako nemamo redove gde se te dve vrednosti razlikuju, onda moramo da odbacimo početnu pretpostavku da možemo koristiti vrednosti za *checkin* iz kolone *house_rules.*

```{r}
length(which(check_info$checkin_real != check_info$checkin_possible))
```

Pošto je vrednost 0, donosimo zaključak da nam pretpostavka nije dobra i da moramo da je odbacimo. Proverićemo da li je ista situacija i za *checkout*.

```{r}
regex <- "Check out: [^,]+"
check_info$checkout_real = airbnb_df$checkout
check_info$checkout_possible = str_extract(airbnb_df$house_rules, regex)
check_info$checkout_possible = str_replace(check_info$checkout_possible, "Check out: ", "")
check_info$checkout_possible = str_replace_all(check_info$checkout_possible, ":", " ")
head(check_info)
```

Dolazimo do istog zaključka kao malopre - vidimo da su vrednosti za prvih nekoliko redova iste, ali proverićemo da li to važi za sve redove. Ako važi, odnosno ako nemamo redove gde se te dve vrednosti razlikuju, onda moramo da odbacimo početnu pretpostavku da možemo koristiti vrednosti za *checkout* iz kolone *house_rules.*

```{r}
length(which(check_info$checkout_real != check_info$checkout_possible))
```

Pošto je ista situacija kao i kod *checkin*, pogledaćemo kakva je raspodela po vrednostima za vrednosti koje nisu NA da bismo odredili najzastupljeniju i nju iskoristile kao vrednost za imputaciju. Pogledajmo kakva je raspodela po vrednostima za vrednosti koje nisu NA

```{r}
checkin_count = airbnb_df %>% 
  filter(!is.na(checkin)) %>%
  count(checkin, sort = TRUE) %>%
  rename(count=n)

head(checkin_count) 
```

Najzastupljenija vrednost jeste *After 3 00 pm* tako da bismo nju mogli da iskoristimo za popunjavanje NA vrednosti. Sačuvaćemo je, kako bismo je kasnije iskoristile za imputaciju.

```{r}
checkin_top_freq = checkin_count$checkin[1]
checkin_top_freq
```

Isti postupak ćemo uraditi i za kolonu *checkout*.

```{r}
checkout_count = airbnb_df %>% 
  filter(!is.na(checkout)) %>%
  count(checkout, sort = TRUE) %>%
  rename(count=n)

head(checkout_count)
```

Najzastupljenija vrednost jeste *11 00 am* tako da ćemo nju iskoristiti za popunjavanje NA vrednosti,

```{r}
checkout_top_freq = checkout_count$checkout[1]
checkout_top_freq
```

Sada ćemo odraditi imputaciju vrednosti za ove dve kolone:

```{r}
airbnb_df$checkin[is.na(airbnb_df$checkin)] = checkin_top_freq
sum(is.na(airbnb_df$checkin))
```

```{r}
airbnb_df$checkout[is.na(airbnb_df$checkout)] = checkout_top_freq
sum(is.na(airbnb_df$checkout))
```

# Analiza, transformacija i vizeulizacija podataka

### Izdvajanje potrebnih kolona

Kolone koje imamo u našem skupu podataka su sledeće:

```{r}
colnames(airbnb_df)
```

Međutim, na osnovu domenskog znanja, možemo odmah da eliminišemo određene kolone za koje znamo da ne bi doprineli predikcijama i zaključivanju.

Kolone kao što su *id, name, host_id, img_links* su kolone koje su jedinstvene i na osnovu njih ne možemo da donesemo nikakve zaključke. Zato ih nećemo uključiti u našu dalju analizu.

```{r}
airbnb_df = airbnb_df %>%
  select(-c(id, name, host_id, img_links))
```

### Ispitivanje odabranih kolona

#### Rating

Pogledajmo vrednosti u ovoj koloni

```{r}
head(airbnb_df$rating, 10)
```

Na osnovu pregleda vrednosti, možemo da primetimo da je rejting tipa *character*, a trebalo bi da bude numerička s obzirom da čuva decimalne vrednosti. Problem pravi specifična vrednost *New* i moramo da je obradimo. Bilo bi očekivano da jednostavno stavimo 0, ali ne smemo to da uradimo jer smeštaj sa oznakom *New* nema stvarno rejting 0. To je nov smeštaj na platformi i zato ćemo da stavimo NA vrednost kako bi dalje mogle da radimo sa kolonom.

```{r}
airbnb_df$rating[airbnb_df$rating == "New"] = NA
airbnb_df$rating = as.numeric(airbnb_df$rating)
```

Da vidimo kakva je distribucija podataka u ovoj koloni

```{r}
rating_df <- airbnb_df %>% 
  count(rating, sort=TRUE) %>%
  rename(count = n)
head(rating_df, n=10)
```

Pogledajmo distribuciju podataka koje nisu NA vrednosti:

```{r}
airbnb_df%>%
  filter(!is.na(rating))%>%
  ggplot(aes(x = rating)) +
  geom_histogram(binwidth = 0.2, fill = "aquamarine", breaks = seq(0, 5, by = 0.25)) +
  labs(title = "Reservations by ratings",
       x = "Rating",
       y = "Reservations") +
  theme_minimal()
```

Na histogramu možemo da potvrdimo ono što smo videli i tabelarno, smeštaji većinski imaju prosečnu ocenu preko 4.5, a ne možemo da vidimo ocene smeštaja koje su ispod 4. Zato ćemo pogledati naredni dijagram:

```{r}
airbnb_df %>%
  filter(!is.na(rating)) %>%
  mutate(index = row_number()) %>%
  ggplot(aes(x = index, y = rating, color = rating)) +
  geom_point(position="jitter") +
  labs(title = "Reservations by ratings",
       x = "Rating",
       y = "Reservations") +
  theme_minimal() + 
  theme(axis.text.x = element_blank()) +
  scale_color_gradient(low = "darkgoldenrod1", high = "aquamarine")
```

Sada možemo bolje da vidimo udeo smeštaja sa manjom prosečnom ocenom.

Smeštaje ćemo razvrstati u kategorije na osnovu njihovog rejtinga. Da bismo odredili granice intervala, pogledaćemo distribuciju podataka po kvantilima:

```{r}
summary(airbnb_df$rating)
```

Vrednosti kvantila su jako visoke i ne oslikavaju realne kategorije smeštaja. Na osnovu domenskog znanja, sprovele smo sledeću podelu kategorija na osnovu rejtinga čiji je tabelarni i vizuelni prikaz dat ispod:

```{r}
breaks = c(-Inf, 0, 3.00, 4.00, 4.25, 4.50, 4.75, 5.00)
labels = c("New", "Poor", "Fair", "Good", "Very Good", "Excellent", "Perfect")
airbnb_df$rating_cat = cut(airbnb_df$rating,  
                           breaks = breaks, 
                           labels = labels)
airbnb_df$rating_cat[is.na(airbnb_df$rating)] = "New"
airbnb_df$rating_cat = factor(airbnb_df$rating_cat)
summary(airbnb_df$rating_cat)
```

```{r}
ggplot(airbnb_df, aes(x = rating_cat, fill = rating_cat)) +
  geom_bar(stat = "count") +
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.5, color = "black", size = 3) +
  labs(title = "Number of reservations by rating category",
       x = "Rating category", 
       y = "Reservations") + 
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")
```

Očekivano, veliki broj smeštaja pripada kategorijama *Excellent* i *Perfect*, a da malo njih ima ocenu ispod 4.25. Takođe, veliki broj smeštaja je nov na platformi - čak 4237.

Na kraju, prebacićemo *reviews* u numeričku vrednost:

```{r}
airbnb_df$reviews = as.numeric(airbnb_df$reviews)
```

#### Guests

Na osnovu ove kolone možemo da vidimo koliko gostiju je odselo u jednom smeštaju.

```{r}
head(airbnb_df$guests, 10)
```

Pogledajmo odnos broja gostiju tabelarno i vizuelno:

```{r}
xtabs(~guests, data=airbnb_df)
```

```{r}
airbnb_df %>%
  count(guests) %>%
  ggplot(aes(x = guests, y = n, fill = factor(guests))) + 
  geom_bar(stat = "identity") + 
  geom_text(aes(label = n),
            vjust = -0.5, color = "black", size = 3) +
  theme_minimal() +
  labs(title = "Number of reservations by guests",
       x = "Guests",
       y = "Reservations")+
  theme(legend.position = "none") 
```

Vidimo da imamo podeoka za goste. Iako imamo rezervacije od po 10+ gostiju, smatramo da to nije neobično, s obzirom da je moguće da se npr. radi o turističkim grupama. S obzirom da imamo preko 10 mogućih vrednosti, a nije isključeno da bi se pojavila i neka nova, obavićemo podelu gostiju u određene grupe.

Na osnovu domenskog znanja i grafika, napravili bi sledeće grupe gostiju:

```{r}
breaks = c(0, 1, 2, 4, 9, Inf)
labels = c("Single", "Pair", "Family", "Friends", "Groups")

airbnb_df$guests_cat = cut(airbnb_df$guests,  
                           breaks = breaks, 
                           labels = labels)
airbnb_df$guests_cat = factor(airbnb_df$guests_cat)
summary(airbnb_df$guests_cat)
```

Ovakvom deobom intervala dobili smo generalno uravnoteženu podelu na kategorije gostiju. Očekivano, manje ima gostiju koji putuju sami ili u velikim grupama u odnosu na parove, porodice i prijatelje.

Pogledajmo kako izgleda vizuelni grafik broja rezervacija po grupi gostiju

```{r}
ggplot(airbnb_df, aes(x = guests_cat, fill = guests_cat)) +
  geom_bar(stat = "count") +
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.5, color = "black", size = 3) +
  labs(title = "Number of reservations by guests category",
       x = "Guests category", 
       y = "Reservations") + 
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")
```

###Bathrooms

Predstavlja broj kupatila po smeštaju:

```{r}
head(airbnb_df$bathrooms, 10)
```

Tabelarni i grafički prikaz broja kupatila po smeštajima:

```{r}
table(bedrooms = airbnb_df$bathrooms)
```

```{r}
airbnb_df %>%
  count(bathrooms) %>%
  ggplot(aes(x = bathrooms, y = n, fill = factor(bathrooms))) + 
  geom_bar(stat = "identity") + 
  geom_text(aes(label = n),
            vjust = -0.5, color = "black", size = 3) +
  theme_minimal() +
  labs(title = "Number of reservations by bathrooms",
       x = "Bathrooms",
       y = "Reservations")+
  theme(legend.position = "none")
```

Vidimo neke neočekivane vrednosti - 0 kupatila, ali i određene smeštaje koji imaju po 20+ kupatila. Što se tiče kupatila koja imaju vrednost 0, moguće je da se radi o hostelima ili pak, o smeštajima gde se izdaju samo sobe. S obzirom na širok opseg vrednosti, grupisaćemo kupatila u određene kategorije kako bismo bolje videle kakva je njihova raspodela:

```{r}
breaks = c(-Inf, 0, 1, 2, 3, Inf)
labels = c("0", "1", "2", "3", "3+")

airbnb_df$bathrooms_cat = cut(airbnb_df$bathrooms,  
                             breaks = breaks, 
                             labels = labels)

summary(airbnb_df$bathrooms_cat)
```

```{r}
ggplot(airbnb_df, aes(x = bathrooms_cat, fill = bathrooms_cat)) +
  geom_bar(stat = "count") +
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.5, color = "black", size = 3) +
  labs(title = "Reservations by number of bathrooms",
       x = "Bathrooms", 
       y = "Reservations") + 
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")
```

Dakle, uobičajeno je da smeštaji imaju jedno kupatilo, ali postoji i određen broj smeštaja sa 2+ kupatila, kao i mali broj smeštaja koja ih uopšte nemaju.

#### Bedrooms

Predstavlja broj soba u smeštaju

```{r}
head(airbnb_df$bedrooms, 10)
```

Prikazaćemo tabelarno i vizuelno broj rezervisanih soba

```{r}
table(bedrooms = airbnb_df$bedrooms)
```

```{r}
airbnb_df %>%
  count(bedrooms) %>%
  ggplot(aes(x = bedrooms, y = n, fill = factor(bedrooms))) + 
  geom_bar(stat = "identity") + 
   geom_text(aes(label = n),
            vjust = -0.5, color = "black", size = 3) +
  theme_minimal() +
  labs(title = "Number of reservations by bedrooms",
       x = "Bedrooms",
       y = "Reservations")+
  theme(legend.position = "none")
```

Očekivano, imamo dominantne vrednosti za jednu, dve i tri sobe. Međutim, imamo određeni broj smeštaja koji nemaju sobu (moguće je da su u pitanju hosteli), a isto tako imamo i rezervacije gde je broj soba čak 50 (hotelski kompleksi).

S obzirom na veliki broj mogućih vrednosti, napravićemo kategorije smeštaja na osnovu broja soba. Uglavnom su sobe, jednokrevetne, dvokrevetne ili trokrevetne tako da ćemo to posmatrati kao zasebne kategorije. Sve preko 3 sobe ćemo smestiti u jednu kategoriju jer je njihova učestalost veoma mala, a isto važi i za smeštaje bez soba. Kako bi tabelarno i vizuelno izgledala nova podela:

```{r}
breaks = c(-Inf, 0, 1, 2, 3, Inf)
labels = c("None/Studio", "1", "2", "3", "3+")

airbnb_df$bedrooms_cat = cut(airbnb_df$bedrooms,  
                             breaks = breaks, 
                             labels = labels)

summary(airbnb_df$bedrooms_cat)

```

```{r}
ggplot(airbnb_df, aes(x = bedrooms_cat, fill = bedrooms_cat)) +
  geom_bar(stat = "count") +
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.5, color = "black", size = 3) +
  labs(title = "Number of reservations by number of rooms",
       x = "Number of rooms", 
       y = "Reservations") + 
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")
```

#### Studio

Studio je tip smeštaja koji se sastoji od jedne prostorije i ona predstavlja i spavaću sobu i dnevnu sobu i kuhinju. Ovakav tip smeštaja je najčešće namenjen za pojedince, parove ili tročlane porodice, ali ima i kada može da se smesti 4 ili 5 gostiju.

```{r}
head(airbnb_df$studios, 10)
```

Pogledajmo da li su rezervacije većinski studio ili ne:

```{r}
table(airbnb_df$studios)
```

Ova numerička kolona zapravo vrši klasifikaciju, tako da ćemo je konvertovati u kategorijsku:

```{r}
airbnb_df$studios = factor(airbnb_df$studios)
levels(airbnb_df$studios) = c("No", "Yes")
table(airbnb_df$studios)
```

Pogledajmo koliko smeštaja se smatra studiom, a koliko ne:

```{r}
airbnb_df %>%
  ggplot(aes(x=studios, fill=studios)) + 
  geom_bar(stat = "count") +
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.5, color = "black", size = 3) +
  scale_fill_brewer(palette = "Set2") + 
  theme_minimal() +
  labs(title = "Reservations by studios",
       x = "Studios",
       y = "Reservations")
```

Možemo da vidimo koje grupe gostiju odsedaju u studiu:

```{r}
airbnb_df %>%
  filter(studios == "Yes")%>%
  ggplot(aes(x = guests, fill = guests_cat)) +
  geom_bar(stat = "count") +
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.5, color = "black", size = 3) +
  labs(title = "Typical number of guests in studio",
       x = "Number of guests", 
       y = "Reservations") + 
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")
```

Vidimo neobične vrednosti - u određenim studijima je bilo i više od 5 gostiju, Pogledajmo koliki je broj takvih smeštaja:

```{r}
length(which(airbnb_df$guests>5 & airbnb_df$studios=="Yes"))
```

Mogli bismo da razmotrimo njihovo brisanje ako čine mali procentualni udeo

```{r}
length(which(airbnb_df$studios=="Yes"))/length(which(airbnb_df$guests>5 & airbnb_df$studios=="Yes"))
```

Ove vrednosti čine čak 19% podataka u ovoj koloni pa ne bi bilo poželjno da obrišemo ove kolone. Pogledajmo distribuciju podataka preko funkcije *summary*

```{r}
summary(factor(airbnb_df$guests[airbnb_df$studios=="Yes"]))
```

S obzirom da je u pitanju mali broj observacija na celom skupu, promenićemo vrednosti da budu granična vrednost tj. 5 gostiju.

```{r}
airbnb_df$guests[airbnb_df$guests>5 & airbnb_df$studios=="Yes"] = 5
```

#### Beds

Ovo je kolona sa informacijama o broju kreveta po smeštaju.

```{r}
head(airbnb_df$beds, 10)
```

Pogledajmo kakva je tabelarna i vizuelna podela:

```{r}
xtabs(~beds, data=airbnb_df)
```

```{r}
airbnb_df %>%
  count(beds) %>%
  ggplot(aes(x = beds, y = n, fill = factor(beds))) + 
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(title = "Number of reservations by beds",
       x = "Beds",
       y = "Reservations")+
  theme(legend.position = "none")
```

Vidimo da imamo ekstremne vrednosti za broj kreveta - čak 98, ali isto tako imamo da je broj kreveta jednak 0 što nam izaziva određenu sumnju.

Pogledajmo kakav je odnos broja kreveta i broja soba:

```{r}
ggplot(airbnb_df, aes(x = bedrooms, y = beds, color=beds)) +
  geom_point(size = 2, position="jitter") +
  labs(title = "Odnos soba i broja kreveta",
       x = "Rooms",
       y = "Beds",
       color = "Beds") +
  theme_minimal() + 
  scale_color_gradient(low = "aquamarine1", high = "darkgoldenrod1")
  
```

Na osnovu grafika, javlja se određena sumnja da imamo observacije koje imaju 0 soba i 0 kreveta zato ćemo pogledati koliko takvih slučajeva imamo:

```{r}
length(which(airbnb_df$bedrooms == 0 & airbnb_df$beds == 0))
```

Pogledajmo da li su ove specifične vrednosti u vezi sa studiom:

```{r}
airbnb_df %>%
  filter(bedrooms == 0, beds == 0) %>%
  ggplot(aes(x = studios, fill=studios)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.5, color = "black", size = 3) +
  scale_fill_brewer(palette = "Set2") + 
  theme_minimal() +
  labs(title = "Zero bedrooms/beds by studio",
       x = "Studios",
       y = "Reservations") 
```

Studio i jesu prostorije koje nemaju sobe, odnosno objedinjene su i soba i kuhinja. Utvrdile smo da vrednosti koje imaju 0 soba i 0 kreveta, ali su studio jesu validne vrednosti. Dakle, observacije koje nemaju ni krevet, ni sobu, a nisu ni studio, jesu kandidari za brisanje. Sa grafika možemo da vidimo da imamo 24 observacije koje su potencijalni kandidati za brisanje. Analiziraćemo samo te redove i izdvojićemo kolone koje bi mogle da nam budu od značaja:

```{r}
zero_bedrooms_beds = airbnb_df %>%
  filter(bedrooms == 0, beds == 0, studios == "No") %>%
  select(features, reviews, rating, rating_cat, country, bathrooms, guests)
zero_bedrooms_beds
```

S obzirom da ovi objekti imaju recenzije i rejting, neki su i novi na platfomi, a ostale vrednosti su u skladu sa očekivanjima, pretpostavljamo da su ovo objekti na otvorenom ili prostori za izdavanje tako da ih nećemo brisati.

Imamo i observacije gde je veliki broj soba, mali broj kreveta. Ako je i mali broj gostiju u tom slučaju, vrlo je verovatno da se radi o nekim ekstremnim vrednostima. Pogledajmo koliko takvih observacija imamo:

```{r}
p=airbnb_df %>%
  filter(beds > 0) %>%
  filter((beds / bedrooms < 0.5) & (guests<=2*beds)) %>%
  select(beds, bedrooms, bathrooms, guests)
```

Ako imamo mali broj ovakvih vrednosti, mogli bismo da ih obrišemo:

```{r}
nrow(p)
```

Imamo mali broj vrednosti, tako da ćemo očistit skup podataka od ovih vrednosti:

```{r}
airbnb_df = airbnb_df %>%
  filter(!(beds > 0 & (beds / bedrooms < 0.5) & (guests <= 2 * beds)))
```

#### Checkin

Checkin je kolona u kojoj imamo informacije o tome u kom periodu dana, gosti treba da stignu u smeštaj

```{r}
head(airbnb_df$checkin)
```

Pogledajmo koliko jedinstvenih vrednosti imamo u ovoj koloni:

```{r}
length(unique(airbnb_df$checkin))
```

Gostima ume da bude bitno da li je vreme dolaska fleksibilno ili ne. Zato ćemo napraviti dve kategorije - gde je vreme fleksibilno i gde nije.

```{r}
airbnb_df$checkin_flexible = "No"
airbnb_df$checkin_flexible[airbnb_df$checkin == "Flexible"] = "Yes"
airbnb_df$checkin_flexible <- factor(airbnb_df$checkin_flexible)

```

Da pogledamo kakva je podela:

```{r}
ggplot(airbnb_df, aes(x = checkin_flexible, fill = checkin_flexible)) + 
  geom_bar() + 
  stat_count(aes(label = ..count..), geom = "text", vjust = -0.5, size = 3) + 
  scale_fill_brewer(palette = "Set2") + 
  theme_minimal() +
  labs(title = "Number of reservations by flexible check-in",
       x = "Flexible",
       y = "Reservations")
```

Vidimo da je u znantnom broju smeštaja vreme dolaska nefleksibilno, odnosno, strogo je definisano.

#### Checkout

Checkout je kolona u kojoj imamo informacije o tome do kad treba da stignemo u smeštaj. Pogledajmo prvo raspodelu vrednosti u ovoj koloni:

```{r}
head(airbnb_df$checkin)
```

Pogledajmo koliko jedinstvenih vrednosti imamo u ovoj koloni

```{r}
length(unique(airbnb_df$checkout))
```

Imamo solidan broj različiih vrednosti - 21, pogledajmo vizuelnu raspodelu podataka

```{r}
airbnb_df %>%
  arrange(checkout) %>%
  ggplot(aes(x = checkout, fill = checkout)) + 
  geom_bar() + 
  stat_count(aes(label = ..count..), geom = "text", vjust = -0.5, size = 3) + 
  theme_minimal() +
  labs(title = "Number of reservations by checkout",
       x = "Checkout",
       y = "Reservations") +
  theme(legend.position = "bottom", 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

Za razliku od malopre, nemamo mogućnost fleksibilnog *checkout-a*, a uobičeno vreme napuštanja smeštaja je 12am. Zato ćemo da podelimo podatke u zavisnosti od toga da li je apartman potrebno napustiti do 12 sati popodne ili ne.

```{r}
airbnb_df$checkout_period  = "PM"
airbnb_df$checkout_period[str_detect(airbnb_df$checkout, "am")] = "AM"

airbnb_df$checkin_flexible <- factor(airbnb_df$checkout_period)
```

Pogledajmo rezultate podele grafički:

```{r}
ggplot(airbnb_df, aes(x = checkin_flexible, fill = checkin_flexible)) + 
  geom_bar() + 
  stat_count(aes(label = ..count..), geom = "text", vjust = -0.5, size = 3) + 
  scale_fill_brewer(palette = "Set2") + 
  theme_minimal() +
  labs(title = "Number of reservations by AM/PM checkout",
       x = "Count",
       y = "Reservations")
```

#### Country

Lokacija, odnosno, država smeštaja je jako bitna jer cene variraju od države do države. Pogledajmo vrednosti u ovoj koloni:

```{r}
head(airbnb_df$country)
```

Hoćemo da vidimo koji je broj rezervacija po državi tabelarno i grafički:

```{r}
country_df = airbnb_df %>%
  group_by(country) %>%
  summarise(reservations = n(), .groups = 'drop') %>%
  arrange(desc(reservations))
head(country_df)
```

Vidimo da najveći broj rezervacija imamo za Indiju, dok imamo duplo manje za Italiju i nešto manje za Grčku. Da bismo odradili vizuelizaciju, bitno nam je da znamo koliko država imamo:

```{r}
nrow(country_df)
```

```{r}
country_df %>%
  mutate(panel = cut(row_number(), breaks = 4, labels = c("Panel 1", "Panel 2", "Panel 3", "Panel 4"))) %>%
  ggplot(aes(x = country, y = reservations, fill = country)) +
  geom_bar(stat = "identity") +
  labs(title = "Broj rezervacija po državi",
       x = "Država",
       y = "Broj rezervacija") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 3)) +
  facet_wrap(~ panel, scales = "free") +
  theme(legend.position = "none")
```

#### House rules

U okviru ove kolone imamo informacije koje bi nam potencijalmo koristile u predikciji. Obavićemo kratak pregled podataka u ovoj koloni kako bi videle koje dodatne informacije možemo da dobijemo:

```{r}
head(airbnb_df$house_rules, n=15)
```

Možemo da dođemo do sledećih informacija: da li su u smeštaju dozvoljeni kućni ljubimci, pušenje, žurke i da li je pogodno za bebe. U nastavku ćemo videti kakva je distribucija ovih vrednosti:

**Pet friendly**

Prvo ćemo da vidimo koliko smeštaja dozvoljava kućne ljubimce

```{r}
airbnb_df$pet_friendly[str_detect(airbnb_df$house_rules, "Pets are allowed")]="Yes"
airbnb_df$pet_friendly[str_detect(airbnb_df$house_rules, "No pets")]="No"
```

Definisana je nova kolona, pogledajmo kakva je podela vrednosti:

```{r}
ggplot(airbnb_df, aes(x = pet_friendly, fill = pet_friendly)) + 
  geom_bar() + 
  stat_count(aes(label = ..count..), geom = "text", vjust = -0.5, size = 3) + 
  theme_minimal() +
  labs(title = "Number of reservations by Pet friendly",
       x = "Pet friendly",
       y = "Reservations") + 
  scale_fill_manual(values = c("aquamarine", "darkgoldenrod1"))
```

Na osnovu grafika možemo reći da više smeštaja ne dozvoljava kućne ljubimce. Takođe, prisutan je određen broj NA vrednosti koje treba popuniti. Kultura čuvanja ljubimaca zavisi od države do države, tako da ćemo videti kakva je podela vrednosti u zavisnosti od tog faktora

```{r}
country_pets_df <- airbnb_df %>%
  group_by(country, pet_friendly) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(country, desc(pet_friendly))

head(country_pets_df)
```

Pre nego što grafički prikažemo ovo, potrebno je da definišemo određene promenljive za ovakav vid iscrtavanja grafika:

```{r}
page_size = 4
num_countries = n_distinct(country_pets_df$country)
total_pages = ceiling(num_countries / page_size)
countries = unique(country_pets_df$country)
```

Pogledajmo grafički prikaz ovog skupa podataka

```{r}
create_and_show_plot <- function(page_data, page_number) {
  p = ggplot(page_data, aes(x = country, y = count, fill = pet_friendly)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_text(aes(label = count), position = position_dodge(width = 0.9), vjust = -0.5, size = 3) +
    labs(title = paste("Page", page_number, "Reservations by Pet friendly & Country"),
         x = "Country",
         y = "Reservations",
         fill = "Pet friendly") +
    theme_minimal() +
    scale_fill_manual(values = c("aquamarine", "darkgoldenrod1")) +
    theme(legend.position = "bottom")
  
  print(p)
}

for (i in 1:total_pages) {
  start_index = (i - 1) * page_size + 1
  end_index = min(i * page_size, num_countries)
  current_countries = countries[start_index:end_index]
  page_data = country_pets_df %>% 
    filter(country %in% current_countries)
  
  create_and_show_plot(page_data, i)
}
```

Iako na globalnom nivou, više smeštaja ne dozvoljava, vidimo da je u određenim državama dominantnije da smeštaji dozvoljavaju kućne ljubimce. Pošto je ovo veliki skup podataka, proverićemo da li imamo neke države gde nemamo nikakvu informaciju o tome da li dozvoljavaju kućne ljubimce i koja vrednost dominira za svaku državu:

```{r}
country_pets_max_df <- country_pets_df %>%
  arrange(country, desc(count), desc(pet_friendly)) %>%
  group_by(country) %>%
  slice_max(order_by = count, n = 1, with_ties = FALSE) %>%
  ungroup()
head(country_pets_max_df)
```

```{r}
country_pets_max_df[is.na(country_pets_max_df$pet_friendly), ]
```

Vidimo da imamo 4 države za koje nemamo uopšte podatak o tome da li dozvoljavaju ili ne dozvoljavaju kućne ljubimce. S obzirom na domensko znanje, ali i prednost Not Pet Friendly smeštaja u odnosu na Pet Friendly, za ove države ćemo staviti vrednost "No".

```{r}
country_pets_max_df$pet_friendly[is.na(country_pets_max_df$pet_friendly)] = "No"
(sum(is.na(country_pets_max_df$pet_friendly)))
```

Sada ćemo popuniti vrednosti u glavnom skupu podataka:

```{r}
na_indices <- which(is.na(airbnb_df$pet_friendly))
airbnb_df$pet_friendly[na_indices] = sapply(airbnb_df$country[na_indices], function(x) {
  value=country_pets_max_df$pet_friendly[country_pets_max_df$country == x]
  return(value[1])
})
sum(is.na(airbnb_df$pet_friendly))
```

**Smoking**

Gostima koji su pušači je bitno da li je u smeštaju u kom borave dozvoljeno ili ne. Potrebno je da koloni *smoking_allowed* dodelimo vrednosti na osnovu kolone *hourse_rules*.

```{r}
airbnb_df$smoking_allowed[str_detect(airbnb_df$house_rules, "Smoking is allowed")]="Yes"
airbnb_df$smoking_allowed[str_detect(airbnb_df$house_rules, "No smoking")]="No"
```

```{r}
ggplot(airbnb_df, aes(x = smoking_allowed, fill = smoking_allowed)) + 
  geom_bar() + 
  stat_count(aes(label = ..count..), geom = "text", vjust = -0.5, size = 3) + 
  theme_minimal() +
  labs(title = "Number of reservations by allowed smoking",
       x = "Allowed smoking",
       y = "Reservations") + 
  scale_fill_manual(values = c("aquamarine", "darkgoldenrod1"))
```

Pogledajmo kako su vrednosti raspodeljene po državam prvo tabelarno, a onda i vizuelno:

```{r}
country_smoking_df <- airbnb_df %>%
  group_by(country, smoking_allowed) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(country, desc(smoking_allowed))

country_smoking_df
```

```{r}
create_and_show_plot <- function(page_data, page_number) {
  p = ggplot(page_data, aes(x = country, y = count, fill = smoking_allowed)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_text(aes(label = count), position = position_dodge(width = 0.9), vjust = -0.5, size = 3) +
    labs(title = paste("Page", page_number, "Reservations by Smoking & Country"),
         x = "Country",
         y = "Reservations",
         fill = "Smoking") +
    theme_minimal() +
    scale_fill_manual(values = c("aquamarine", "darkgoldenrod1")) +
    theme(legend.position = "bottom")
  print(p)
}

for (i in 1:total_pages) {
  start_index = (i - 1) * page_size + 1
  end_index = min(i * page_size, num_countries)
  current_countries = countries[start_index:end_index]
  page_data = country_smoking_df %>% 
    filter(country %in% current_countries)
  
  create_and_show_plot(page_data, i)
}
```

Isto gledamo da li imamo neku državu za koju uopšte nemamo vrednost i koja je dominantna vrednost za svaku državu.

```{r}
country_smoking_max_df = country_smoking_df %>%
  arrange(country, desc(count), desc(smoking_allowed)) %>%
  group_by(country) %>%
  slice_max(order_by = count, with_ties = FALSE)
  
country_smoking_max_df
```

```{r}
country_smoking_max_df[is.na(country_smoking_max_df$smoking_allowed), ]
```

Isto kao i za pet friendly, i ovde ćemo popuniti vrednosti sa No.

```{r}
country_smoking_max_df$smoking_allowed[is.na(country_smoking_max_df$smoking_allowed)] = "No"
(sum(is.na(country_smoking_max_df$smoking_allowed)))
```

Sada popunjavamo vrednosti u glavnom skupu

```{r}
na_indices <- which(is.na(airbnb_df$smoking_allowed))
airbnb_df$smoking_allowed[na_indices] = sapply(airbnb_df$country[na_indices], function(x) {
  value=country_smoking_max_df$smoking_allowed[country_smoking_max_df$country == x]
  return(value[1])
})
sum(is.na(airbnb_df$smoking_allowed))
```

**Suitible for infants**

Ova kolona treba da pruži informacije da li je smeštaj prigodan za bebe ili ne. Potrebno je da koloni *suitibile_for_infants* dodelimo vrednosti na osnovu kolone *hourse_rules*. Vlasnici smeštaja uglavnom naglašavaju ako u smeštaju nije pogodno za bebe, tako da ćemo podrazumevati da je pogodno za bebe, osim ako nije drugačije rečeno.

```{r}
airbnb_df$suitibile_for_infants = "Yes"
airbnb_df$suitibile_for_infants[str_detect(airbnb_df$house_rules, "Not suitable for infants")]="No"
```

```{r}
ggplot(airbnb_df, aes(x = suitibile_for_infants, fill = suitibile_for_infants)) + 
  geom_bar() + 
  stat_count(aes(label = ..count..), geom = "text", vjust = -0.5, size = 3) + 
  theme_minimal() +
  labs(title = "Number of reservations by suitible for infants",
       x = "Suitible for infants",
       y = "Reservations") + 
  scale_fill_manual(values = c("aquamarine", "darkgoldenrod1"))
```

Pogledajmo kako su vrednosti raspodeljene po državam prvo tabelarno, a onda i vizuelno:

```{r}
country_infants_df <- airbnb_df %>%
  group_by(country, suitibile_for_infants) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(country, desc(suitibile_for_infants))

country_infants_df
```

```{r}
create_and_show_plot <- function(page_data, page_number) {
  p = ggplot(page_data, aes(x = country, y = count, fill = suitibile_for_infants)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_text(aes(label = count), position = position_dodge(width = 0.9), vjust = -0.5, size = 3) +
    labs(title = paste("Page", page_number, "Reservations by Suitible for infants & Country"),
         x = "Country",
         y = "Reservations",
         fill = "Suitible for infants") +
    theme_minimal() +
    scale_fill_manual(values = c("aquamarine", "darkgoldenrod1")) +
    theme(legend.position = "bottom")
  
  print(p)
}

for (i in 1:total_pages) {
  start_index = (i - 1) * page_size + 1
  end_index = min(i * page_size, num_countries)
  current_countries = countries[start_index:end_index]
  page_data = country_infants_df %>% 
    filter(country %in% current_countries)
  
  create_and_show_plot(page_data, i)
}
```

Pоšto smo se pobrinule za NA vrednosti, prebacićemo ove kolone u kategorijske:

```{r}
airbnb_df$pet_friendly = factor(airbnb_df$pet_friendly)
airbnb_df$smoking_allowed = factor(airbnb_df$smoking_allowed)
airbnb_df$suitibile_for_infants = factor(airbnb_df$suitibile_for_infants)
```

#### Price

Cena je promenljiva koju predviđamo. Ona je data u lokalnoj valuti što nam ne odgovara jer nećemo imati dobre predikcije. Konvertovaćemo sve cene u dinare. Da bismo to uradile, potreban nam je kod valute.

```{r}
countries_data <- codelist
zemlje_valute <- countries_data %>%
select(country.name.en, currency)  
airbnb_df$currency_code <- NA 
airbnb_df$country=trimws(airbnb_df$country)
 
for (i in 1:nrow(airbnb_df)) {
  country <- airbnb_df$country[i]
  match_index <- which(zemlje_valute$country.name.en == country)
  if (length(match_index) > 0) {
    airbnb_df$currency_code[i] <- zemlje_valute$currency[match_index]
  }
}
```

Iz csv fajla ćemo dobiti informacije o trenutnom kursu valute i svakoj observaciji ćemo pridružiti kurs i njegovu vrednost.

```{r}
exchange_rates_df <- read.csv('currency_exchange_rates.csv')

airbnb_with_rates <- merge(airbnb_df, exchange_rates_df, by.x = "currency_code", by.y = "Currency", all.x = TRUE)

head(airbnb_with_rates)
```

Moguće je da za neke observacije nemamo vrednosti za kurs. Proverićemo koliko takvih observacija imamo:

```{r}
sum(is.na(airbnb_with_rates$Exchange_Rate_RSD))
```

Imamo svega 11 redova, pogledajmo koje su države u pitanju:

```{r}
unique(airbnb_with_rates$country[is.na(airbnb_with_rates$Exchange_Rate_RSD)])
```

Države nisu česte turističke destinacije, tako da možemo filtrirati podatke i ukloniti ove observacije

```{r}
airbnb_with_rates = airbnb_with_rates %>%
  filter(!is.na(Exchange_Rate_RSD))
```

Pošto više nemamo nedostajućih vrednosti, možemo da pretvorimo lokalnu cenu u cenu u dinarima

```{r}
airbnb_with_rates$priceRSD = airbnb_with_rates$price * airbnb_with_rates$Exchange_Rate_RSD
```

Treba da vidimo kakva je distribucija podataka:

```{r}
summary(airbnb_with_rates$priceRSD)
```

Analizirajući skup podataka koji obuhvata ekstremne vrednosti (outliers), primetili smo značajnu razliku između srednje vrednosti (aritmetičke sredine) i mediane. Dok srednja vrednost može biti značajno uticajna ekstremnim vrednostima, medijana pruža bolji uvid u centralnu tendenciju skupa, zadržavajući stabilnost bez obzira na ekstremne vrednosti. Ova razlika naglašava važnost odabira odgovarajuće mere centralne tendencije u zavisnosti od prirode podataka i ciljeva analize. Outlier-i mogu povući liniju regresije ili uticati na procenu koeficijenata, što može dovesti do nepreciznih predviđanja. Pogledajmo kako će izgledati boxplot:

```{r}
airbnb_with_rates%>%
  ggplot(aes(x = priceRSD)) +
  geom_boxplot() + 
  labs(title = "Distribution of price in RSD",
       x = "",
       y = "Price") +
  theme_minimal()
```

Pošto je skup podataka raznovrsan, uključuje veliki broj država, a i standard po državama se razlikuje - u nekim je jeftinije, u nekim skuplje. Iz tog razloga odradićemo analizu podskupa podatka tj. uzorka. Uzećemo za uzorak rezervacije iz Indije pošto je najveći broj observacija upravo odatle.

# Modeli i predikcije

```{r}
data_india <- airbnb_with_rates[airbnb_with_rates$country == "India", ]
```

Pogledajmo kakva je distribucija cene smeštaja samo u Indiji

```{r}
data_india%>%
  ggplot(aes(x = priceRSD)) +
  geom_boxplot() + 
  labs(title = "Distribution of price in RSD in India",
       x = "",
       y = "Price") +
  theme_minimal()
```

Iako je distribucija malo bolja nego na celokupnom skupu podataka, i dalje imamo ekstremno velike vrednosti. Kako nam ovo ne bi remetilo modele, skaliraćemo cenu čime ćemo postići da outlieri nemaju toliki uticaj. Koristićemo logaritamsku funkciju:

```{r}
data_india$log_price = log(data_india$price)
```

U nastavku ćemo koristiti logaritamsku vrednost cene. Za dalji rad će nam biti potrebne neke osnovne informacije o raspodeli numeričkih kolona:

```{r}
df_numeric <- data_india %>% 
  select(rating, log_price, bathrooms, beds, guests, bedrooms, reviews)
summary(df_numeric)
```

Vidimo da imamo NA vrednosti u koloni reviews. Pošto nam je ta kolona potrebna za model predviđanja, popunićemo nedostajuće vrednosti medijanom.

```{r}
mean_rating = mean(data_india$rating, na.rm = TRUE)
data_india$rating[is.na(data_india$rating)] = mean_rating
```

Pre nego što nastavimo dalji tok rada, podelićemo skup na trening i na test u odnosu 80:20.

```{r}
set.seed(123)
data_india_split <- initial_split(data_india, prop = 0.8, strata = "price")
data_india_train <- training(data_india_split)
data_india_test <- testing(data_india_split)
data_recipe <- recipe(price ~ rating + reviews + bathrooms + bedrooms,
                      data = data_india_train) %>%
  step_scale(all_predictors()) %>%
  step_center(all_predictors())
```

Pogledajmo sad kako izgleda odnos kolona koje smo odabrale za prediktore u odnosu na kolonu koju predviđamo:

```{r}
pairs(df_numeric)
```

Vidimo da najbolji linearni odnos sa cenom imaju kolone bathrooms, beds, guests, bedrooms. Iscrtaćemo grafike za svaku od ovih kolona u odnosu na cenu.

```{r}
ggplot(data_india_train, aes(x = bathrooms, y = log_price)) +
  geom_point(color = "green") +
  labs(title = "Relationship between bathrooms and price") +
  theme_minimal()
```

```{r}
ggplot(data_india, aes(x = beds, y = price)) +
  geom_point(color = "purple") +
  labs(title = "Relationship between beds and price") +
  theme_minimal()
```

```{r}
ggplot(data_india_train, aes(x = guests, y = log_price)) +
  geom_point(color = "orange") +
  labs(title = "Relationship between guests and price") +
  theme_minimal()

```

```{r}
ggplot(data_india_train, aes(x = bedrooms, y = log_price)) +
  geom_point(color = "red") +
  labs(title = "Relationship between bedrooms and price") +
  theme_minimal()
```

Iscrtaćemo korelacionu matricu samo za ove kolone kako bi videle kakva je korelacija između promenljivih

```{r}
correlation_matrix <- cor(data_india_train[c("log_price", "bathrooms", "beds", "guests", "bedrooms", "rating", "reviews")])
print(correlation_matrix)
corrplot(correlation_matrix, method = "circle")
```

Možemo da zaključimo da svi prediktori sem rating i reviews imaju solidnu korelaciju sa output-om.

Napravićemo inicijalni model linearne regresije sa samo ovim kolonama:

```{r}
lm_model <- lm(log_price ~ bathrooms + beds + guests + bedrooms, data = data_india_train)
summary(lm_model)
```

Vidimo da je model loš, standardna rezidualna greška je jako velika - 0.869, a R2 i adjusted R2 su jako niske - 0.2.Svi prediktori imaju značajan uticaj na model, sem prediktora bedrooms.

Generalno, na broj povećanja gostiju, trebalo bi da se povećava i broj kreveta, odnosno u sinergiji su. Kako bi to uticalo na problem i da li bi poboljšalo performanse modela?

```{r}
sinergy_model <- lm(log_price ~ bathrooms + beds + guests + bedrooms + beds*guests, data = data_india_train)
summary(sinergy_model)
plot(sinergy_model)
```

Vidimo da je sinergija doprinela povećanju metrika, ali ne preterano, svega 0.02.

Želimo da vidimo da li na predviđanje cene možda ima veze grad u kom se nalazi smeštaj. Do ovog zaključka smo došle na osnovu domenskog znanja - uvek je skuplje na atraktivnim lokacijama u odnosu na one koje nisu. Izdvojićemo grad iz kolone adresa:

```{r}
data_india_train$city = sapply(data_india_train$address, function(x){
  return (trimws(strsplit(x, ",")[[1]][1]))
})
length(unique(data_india_train$city))
```

Kreiraćemo model koji će uključiti ovu kolonu u predikciju:

```{r}
lm_model2 = lm(price ~ bathrooms + beds + guests + bedrooms + city, data = data_india_train)
summary(lm_model2)
plot(lm_model2)
```

Vidimo da je ovaj prediktor značajno unapredio model ako gledamo R2 statistiku, međutim, adjR2 se malo povećao - 0.27, ali je poprilično velika razlika između ove dve metrike što nije dobro.

Kreiraćemo model koji će sadržati sledeće kolone bathrooms, beds, guests, bedrooms, rating, reviews.

```{r}
lm_model_transformed <- lm(log_price ~ bathrooms + beds + guests + bedrooms+rating+reviews, data = data_india_train)

summary(lm_model_transformed)
plot(lm_model_transformed)
```

Ovaj model ima iste performanse kao i prvi, odnosno, jako loše su. Dakle od svih linearnih modela, najbolje performanse ima model lm_model2.

Sada ćemo da vidimo kakav rezultat će dati Lasso i Ridge.

```{r}
lasso_spec <- linear_reg(penalty = 1, mixture = 1) %>%
  set_engine("glmnet") %>%
  set_mode("regression")

ridge_spec <- linear_reg(penalty = 1, mixture = 0) %>%
  set_engine("glmnet") %>%
  set_mode("regression")

lasso_workflow <- workflow() %>%
  add_recipe(data_recipe) %>%
  add_model(lasso_spec)

ridge_workflow <- workflow() %>%
  add_recipe(data_recipe) %>%
  add_model(ridge_spec)
```

```{r}
lasso_fit <- lasso_workflow %>%
  fit(data = data_india_train)
ridge_fit <- ridge_workflow %>%
  fit(data = data_india_train)

lasso_predictions <- lasso_fit %>%
  predict(new_data = data_india_test)
ridge_predictions <- ridge_fit %>%
  predict(new_data = data_india_test)
```

```{r}
lasso_rmse <- sqrt(mean((data_india_test$price - lasso_predictions$.pred)^2))
cat("Lasso Model RMS Error on Test Set:", lasso_rmse, "\n")

ridge_rmse <- sqrt(mean((data_india_test$price - ridge_predictions$.pred)^2))
cat("Ridge Model RMS Error on Test Set:", ridge_rmse, "\n")
```

Analiza Lasso modela: RMS greška: Lasso Model RMS Error on Test Set iznosi 8659.479. Ova vrednost predstavlja prosečnu kvadratnu grešku (u istim jedinicama kao i ciljna promenljiva, u ovom slučaju cena) koju model pravi u svojim predviđanjima. Niža vrednost RMS greške znači bolju tačnost modela. Parametri modela: Lasso model primenjuje L1 regularizaciju, što znači da može redukovati uticaj nebitnih ili redundantnih atributa na predviđanja, jer postavlja neke koeficijente atributa na tačno nula. Ovo može biti korisno za eliminisanje šuma iz podataka i fokusiranje na bitne atribute. Interpretacija koeficijenata: Lasso model može da dovede do sparse (retke) reprezentacije, tj. da postavi neke koeficijente atributa na nulu. To znači da možeš da identifikuješ koji atributi su najbitniji za predviđanje cene.

Analiza Ridge modela: RMS greška: Ridge Model RMS Error on Test Set iznosi 8662.583. Ova vrednost takođe predstavlja prosečnu kvadratnu grešku modela u predviđanjima cene. U poređenju sa Lasso modelom, Ridge model ima nešto veću RMS grešku, što može ukazivati da će Lasso imati na nešto bolju tačnost u predviđanjima. Parametri modela: Ridge model primenjuje L2 regularizaciju, koja takođe pomaže u kontroli overfittinga tako što smanjuje veličinu koeficijenata atributa. Međutim, za razliku od Lasso modela, ne postavlja koeficijente na tačno nulu, već ih smanjuje proporcionalno njihovoj važnosti. Interpretacija koeficijenata: Ridge model može dati bolju stabilnost i generalizaciju u odnosu na Lasso model, ali može biti manje interpretabilan u smislu jasnog identifikovanja najbitnijih atributa.

Zaključak: Lasso vs Ridge: U ovom slučaju, Ridge model ima nešto bolju RMS grešku u poređenju sa Lasso modelom, što može ukazivati na nešto bolju tačnost u predviđanju cena. Međutim, izbor između ova dva modela može zavisiti i od drugih faktora kao što su interpretabilnost rezultata, potreba za regularizacijom i specifičnosti podataka. Dalje prilagođavanje: Da bi se modeli još više poboljšali, možeš eksperimentisati sa dodatnim atributima, podešavanjem hiperparametara (kao što je jačina regularizacije) ili čak različitim modelima kako bi se videlo koji najbolje odgovara tvojim podacima.

```{r}
lasso_predictions <- lasso_fit %>%
  predict(new_data = data_india_test)
 
ridge_predictions <- ridge_fit %>%
  predict(new_data = data_india_test)

results <- data.frame(
  Actual = data_india_test$price,
  Lasso_Predicted = lasso_predictions$.pred,
  Ridge_Predicted = ridge_predictions$.pred
)
 
ggplot(results, aes(x = Actual, y = Lasso_Predicted)) +
  geom_point(color = "aquamarine1") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
  labs(x = "Actual", y = "Predicted (Lasso model)") +
  ggtitle("Predicted vs Actual (Lasso model)") + 
  theme_minimal()
```
